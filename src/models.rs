use diesel::prelude::*;
use uuid::Uuid;

// Import the schema generated by Diesel
use crate::schema::*;

// Queryable structs (for reading from database)
#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = rule_sets)]
pub struct RuleSet {
    pub id: String,
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = versions)]
pub struct Version {
    pub id: String,
    pub rule_set_id: String,
    pub version_name: String,
    pub effective_from: chrono::NaiveDate,
    pub effective_to: Option<chrono::NaiveDate>,
    pub description: Option<String>,
    pub is_current: bool,
    pub created_at: chrono::NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = rules)]
pub struct Rule {
    pub id: String,
    pub slug: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub parent_rule_id: Option<String>,
    pub number: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = rule_content)]
pub struct RuleContent {
    pub id: String,
    pub rule_id: String,
    pub language: String,
    pub content_markdown: String,
    pub source_content_id: Option<String>,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = glossary_terms)]
pub struct GlossaryTerm {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub slug: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = glossary_content)]
pub struct GlossaryContent {
    pub id: String,
    pub term_id: String,
    pub language: String,
    pub term: String,
    pub definition_markdown: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

// Quiz models
#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_questions)]
pub struct QuizQuestion {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_answers)]
pub struct QuizAnswer {
    pub id: String,
    pub question_id: String,
    pub answer_text: String,
    pub is_correct: bool,
    pub sort_order: i32,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_question_rules)]
pub struct QuizQuestionRule {
    pub id: String,
    pub question_id: String,
    pub rule_id: String,
    pub created_at: String,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_attempts)]
pub struct QuizAttempt {
    pub id: String,
    pub session_id: String,
    pub question_id: String,
    pub selected_answer_id: Option<String>,
    pub is_correct: Option<bool>,
    pub response_time_ms: Option<i32>,
    pub created_at: String,
}

// Insertable structs (for creating new records)
#[derive(Insertable, Debug)]
#[diesel(table_name = rule_sets)]
pub struct NewRuleSet {
    pub id: String,
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = versions)]
pub struct NewVersion {
    pub id: String,
    pub rule_set_id: String,
    pub version_name: String,
    pub effective_from: chrono::NaiveDate,
    pub effective_to: Option<chrono::NaiveDate>,
    pub description: Option<String>,
    pub is_current: bool,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = rules)]
pub struct NewRule {
    pub id: String,
    pub slug: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub parent_rule_id: Option<String>,
    pub number: String,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = rule_content)]
pub struct NewRuleContent {
    pub id: String,
    pub rule_id: String,
    pub language: String,
    pub content_markdown: String,
    pub source_content_id: Option<String>,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = glossary_terms)]
pub struct NewGlossaryTerm {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub slug: String,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = glossary_content)]
pub struct NewGlossaryContent {
    pub id: String,
    pub term_id: String,
    pub language: String,
    pub term: String,
    pub definition_markdown: String,
}

// Quiz insertable structs
#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_questions)]
pub struct NewQuizQuestion {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_answers)]
pub struct NewQuizAnswer {
    pub id: String,
    pub question_id: String,
    pub answer_text: String,
    pub is_correct: bool,
    pub sort_order: i32,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_question_rules)]
pub struct NewQuizQuestionRule {
    pub id: String,
    pub question_id: String,
    pub rule_id: String,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_attempts)]
pub struct NewQuizAttempt {
    pub id: String,
    pub session_id: String,
    pub question_id: String,
    pub selected_answer_id: Option<String>,
    pub is_correct: Option<bool>,
    pub response_time_ms: Option<i32>,
}

// Helper functions for generating UUIDs
impl NewRuleSet {
    pub fn new(name: String, slug: String, description: Option<String>) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            name,
            slug,
            description,
        }
    }
}

impl NewVersion {
    pub fn new(
        rule_set_id: String,
        version_name: String,
        effective_from: chrono::NaiveDate,
        effective_to: Option<chrono::NaiveDate>,
        description: Option<String>,
        is_current: bool,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            rule_set_id,
            version_name,
            effective_from,
            effective_to,
            description,
            is_current,
        }
    }
}

impl NewRule {
    pub fn new(
        slug: String,
        rule_set_id: String,
        version_id: String,
        parent_rule_id: Option<String>,
        number: String,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            slug,
            rule_set_id,
            version_id,
            parent_rule_id,
            number,
        }
    }
}

impl NewRuleContent {
    pub fn new(
        rule_id: String,
        language: String,
        content_markdown: String,
        source_content_id: Option<String>,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            rule_id,
            language,
            content_markdown,
            source_content_id,
        }
    }
}

impl NewGlossaryTerm {
    pub fn new(
        rule_set_id: String,
        version_id: String,
        slug: String,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            rule_set_id,
            version_id,
            slug,
        }
    }
}

impl NewGlossaryContent {
    pub fn new(
        term_id: String,
        language: String,
        term: String,
        definition_markdown: String,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            term_id,
            language,
            term,
            definition_markdown,
        }
    }
}

impl NewQuizQuestion {
    pub fn new(
        rule_set_id: String,
        version_id: String,
        question_text: String,
        explanation: String,
        difficulty_level: String,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            rule_set_id,
            version_id,
            question_text,
            explanation,
            difficulty_level,
        }
    }
}

impl NewQuizAnswer {
    pub fn new(
        question_id: String,
        answer_text: String,
        is_correct: bool,
        sort_order: i32,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            question_id,
            answer_text,
            is_correct,
            sort_order,
        }
    }
}

impl NewQuizQuestionRule {
    pub fn new(question_id: String, rule_id: String) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            question_id,
            rule_id,
        }
    }
}

impl NewQuizAttempt {
    pub fn new(
        session_id: String,
        question_id: String,
        selected_answer_id: Option<String>,
        is_correct: Option<bool>,
        response_time_ms: Option<i32>,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            session_id,
            question_id,
            selected_answer_id,
            is_correct,
            response_time_ms,
        }
    }
}

// Business layer structs for quiz operations

/// Business layer representation of a quiz answer
#[derive(Debug, Clone)]
pub struct QuizAnswerData {
    pub answer_text: String,
    pub is_correct: bool,
}

/// Business layer representation of a complete quiz question for creation
#[derive(Debug, Clone)]
pub struct QuizQuestionData {
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
    pub answers: Vec<QuizAnswerData>,
    pub rule_ids: Vec<String>, // Rule IDs this question references
}

impl QuizQuestionData {
    pub fn new(
        rule_set_id: String,
        version_id: String,
        question_text: String,
        explanation: String,
        difficulty_level: String,
        answers: Vec<QuizAnswerData>,
        rule_ids: Vec<String>,
    ) -> Self {
        Self {
            rule_set_id,
            version_id,
            question_text,
            explanation,
            difficulty_level,
            answers,
            rule_ids,
        }
    }

    /// Convert to database entities for creation
    pub fn to_database_entities(&self) -> (NewQuizQuestion, Vec<NewQuizAnswer>, Vec<NewQuizQuestionRule>) {
        let question_id = uuid::Uuid::now_v7().to_string();
        
        let question = NewQuizQuestion {
            id: question_id.clone(),
            rule_set_id: self.rule_set_id.clone(),
            version_id: self.version_id.clone(),
            question_text: self.question_text.clone(),
            explanation: self.explanation.clone(),
            difficulty_level: self.difficulty_level.clone(),
        };

        let answers: Vec<NewQuizAnswer> = self.answers
            .iter()
            .enumerate()
            .map(|(index, answer)| NewQuizAnswer {
                id: uuid::Uuid::now_v7().to_string(),
                question_id: question_id.clone(),
                answer_text: answer.answer_text.clone(),
                is_correct: answer.is_correct,
                sort_order: index as i32,
            })
            .collect();

        let rule_links: Vec<NewQuizQuestionRule> = self.rule_ids
            .iter()
            .map(|rule_id| NewQuizQuestionRule {
                id: uuid::Uuid::now_v7().to_string(),
                question_id: question_id.clone(),
                rule_id: rule_id.clone(),
            })
            .collect();

        (question, answers, rule_links)
    }
}
