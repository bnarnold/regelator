use std::str::FromStr;

use diesel::deserialize::{FromSql, Result as DeserializeResult};
use diesel::expression::AsExpression;
use diesel::prelude::*;
use diesel::serialize::{Output, Result as SerializeResult, ToSql};
use diesel::sqlite::Sqlite;
use diesel::FromSqlRow;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Import the schema generated by Diesel
use crate::schema::*;

// Quiz question status enum
#[derive(Debug, Copy, Clone, PartialEq, Serialize, Deserialize, AsExpression, FromSqlRow)]
#[serde(rename_all = "lowercase")]
#[diesel(sql_type = diesel::sql_types::Text)]
pub enum QuestionStatus {
    Draft,
    Active,
    Archived,
}

impl QuestionStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            QuestionStatus::Draft => "draft",
            QuestionStatus::Active => "active",
            QuestionStatus::Archived => "archived",
        }
    }
}

impl FromStr for QuestionStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "draft" => Ok(QuestionStatus::Draft),
            "active" => Ok(QuestionStatus::Active),
            "archived" => Ok(QuestionStatus::Archived),
            s => Err(format!("invalid question status: {s}")),
        }
    }
}

impl FromSql<diesel::sql_types::Text, Sqlite> for QuestionStatus {
    fn from_sql(
        bytes: <Sqlite as diesel::backend::Backend>::RawValue<'_>,
    ) -> DeserializeResult<Self> {
        let s = <String as FromSql<diesel::sql_types::Text, Sqlite>>::from_sql(bytes)?;
        Ok(Self::from_str(&s)?)
    }
}

impl ToSql<diesel::sql_types::Text, Sqlite> for QuestionStatus {
    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, Sqlite>) -> SerializeResult {
        <str as ToSql<diesel::sql_types::Text, Sqlite>>::to_sql(self.as_str(), out)
    }
}

// Quiz models - Queryable structs (for reading from database)
#[derive(Queryable, Selectable, Debug, Clone, Serialize)]
#[diesel(table_name = quiz_questions)]
#[diesel(check_for_backend(Sqlite))]
pub struct QuizQuestion {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
    pub created_at: String,
    pub updated_at: String,
    pub status: QuestionStatus,
}

#[derive(Queryable, Selectable, Debug, Clone, Serialize)]
#[diesel(table_name = quiz_answers)]
pub struct QuizAnswer {
    pub id: String,
    pub question_id: String,
    pub answer_text: String,
    pub is_correct: bool,
    pub sort_order: i32,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_question_rules)]
pub struct QuizQuestionRule {
    pub id: String,
    pub question_id: String,
    pub rule_id: String,
    pub created_at: String,
}

#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = quiz_attempts)]
#[diesel(check_for_backend(Sqlite))]
pub struct QuizAttempt {
    pub id: String,
    pub session_id: String,
    pub question_id: String,
    pub selected_answer_id: Option<String>,
    pub is_correct: Option<bool>,
    pub response_time_ms: Option<i32>,
    pub created_at: String,
}

// Quiz models - Insertable structs (for creating new records)
#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_questions)]
pub struct NewQuizQuestion {
    pub id: String,
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
    pub status: QuestionStatus,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_answers)]
pub struct NewQuizAnswer {
    pub id: String,
    pub question_id: String,
    pub answer_text: String,
    pub is_correct: bool,
    pub sort_order: i32,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_question_rules)]
pub struct NewQuizQuestionRule {
    pub id: String,
    pub question_id: String,
    pub rule_id: String,
}

#[derive(Insertable, Debug)]
#[diesel(table_name = quiz_attempts)]
pub struct NewQuizAttempt {
    pub id: String,
    pub session_id: String,
    pub question_id: String,
    pub selected_answer_id: Option<String>,
    pub is_correct: Option<bool>,
    pub response_time_ms: Option<i32>,
}

// Helper functions for generating UUIDs - Quiz models
impl NewQuizQuestion {
    pub fn new(
        rule_set_id: String,
        version_id: String,
        question_text: String,
        explanation: String,
        difficulty_level: String,
        status: QuestionStatus,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            rule_set_id,
            version_id,
            question_text,
            explanation,
            difficulty_level,
            status,
        }
    }
}

impl NewQuizAnswer {
    pub fn new(
        question_id: String,
        answer_text: String,
        is_correct: bool,
        sort_order: i32,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            question_id,
            answer_text,
            is_correct,
            sort_order,
        }
    }
}

impl NewQuizQuestionRule {
    pub fn new(question_id: String, rule_id: String) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            question_id,
            rule_id,
        }
    }
}

impl NewQuizAttempt {
    pub fn new(
        session_id: String,
        question_id: String,
        selected_answer_id: Option<String>,
        is_correct: Option<bool>,
        response_time_ms: Option<i32>,
    ) -> Self {
        Self {
            id: Uuid::now_v7().to_string(),
            session_id,
            question_id,
            selected_answer_id,
            is_correct,
            response_time_ms,
        }
    }
}

// Business layer structs for quiz operations

/// Business layer representation of a quiz answer
#[derive(Debug, Clone)]
pub struct QuizAnswerData {
    pub answer_text: String,
    pub is_correct: bool,
}

/// Business layer representation of a complete quiz question for creation
#[derive(Debug, Clone)]
pub struct QuizQuestionData {
    pub rule_set_id: String,
    pub version_id: String,
    pub question_text: String,
    pub explanation: String,
    pub difficulty_level: String,
    pub answers: Vec<QuizAnswerData>,
    pub rule_ids: Vec<String>, // Rule IDs this question references
}

impl QuizQuestionData {
    pub fn new(
        rule_set_id: String,
        version_id: String,
        question_text: String,
        explanation: String,
        difficulty_level: String,
        answers: Vec<QuizAnswerData>,
        rule_ids: Vec<String>,
    ) -> Self {
        Self {
            rule_set_id,
            version_id,
            question_text,
            explanation,
            difficulty_level,
            answers,
            rule_ids,
        }
    }

    /// Convert to database entities for creation
    pub fn to_database_entities(
        &self,
    ) -> (
        NewQuizQuestion,
        Vec<NewQuizAnswer>,
        Vec<NewQuizQuestionRule>,
    ) {
        let question_id = uuid::Uuid::now_v7().to_string();

        let question = NewQuizQuestion {
            id: question_id.clone(),
            rule_set_id: self.rule_set_id.clone(),
            version_id: self.version_id.clone(),
            question_text: self.question_text.clone(),
            explanation: self.explanation.clone(),
            difficulty_level: self.difficulty_level.clone(),
            status: QuestionStatus::Active,
        };

        let answers: Vec<NewQuizAnswer> = self
            .answers
            .iter()
            .enumerate()
            .map(|(index, answer)| NewQuizAnswer {
                id: uuid::Uuid::now_v7().to_string(),
                question_id: question_id.clone(),
                answer_text: answer.answer_text.clone(),
                is_correct: answer.is_correct,
                sort_order: index as i32,
            })
            .collect();

        let rule_links: Vec<NewQuizQuestionRule> = self
            .rule_ids
            .iter()
            .map(|rule_id| NewQuizQuestionRule {
                id: uuid::Uuid::now_v7().to_string(),
                question_id: question_id.clone(),
                rule_id: rule_id.clone(),
            })
            .collect();

        (question, answers, rule_links)
    }
}

/// Session statistics summary
#[derive(Debug, Clone)]
pub struct SessionStatistics {
    pub total_questions: usize,
    pub correct_answers: usize,
    pub accuracy_percentage: u32,
    pub current_streak: usize,
}
